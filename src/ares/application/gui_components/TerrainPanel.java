package ares.application.gui_components;

import ares.data.jaxb.TerrainFeature;
import ares.io.AresIO;
import ares.io.AresPaths;
import ares.platform.util.ImageUtils;
import ares.scenario.Scenario;
import ares.scenario.board.BoardInfo;
import ares.scenario.board.Direction;
import ares.scenario.board.Terrain;
import ares.scenario.board.Tile;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;

/**
 *
 * @author Sergio Musoles
 */
public class TerrainPanel extends javax.swing.JPanel {

    private BoardInfo boardInfo;
    private Map<Terrain, BufferedImage[]> terrainGraphics;
    private Image terrainImage;
    private Image gridImage;
    private boolean showGrid = true;

    /**
     * Creates new form TerrainPanel
     */
    public TerrainPanel() {
        initComponents();
    }

    public void initialize(Scenario scenario) {
        this.boardInfo = new BoardInfo(scenario.getBoard());

        loadGraphics();

        Tile[][] tiles = scenario.getBoard().getMap();
        BufferedImage[][] terrainImages = new BufferedImage[boardInfo.getWidth()][boardInfo.getHeight()];
        BufferedImage[][] hexImages = new BufferedImage[boardInfo.getWidth()][boardInfo.getHeight()];
        for (int i = 0; i < boardInfo.getWidth(); i++) {
            for (int j = 0; j < boardInfo.getHeight(); j++) {
                Tile tile = tiles[i][j];
                int[] flags = obtainTileFlags(tile);
                terrainImages[i][j] = flagsToImage(flags, tile);
            }
        }

        createGlobalTerrainImage(terrainImages);

        BufferedImage hexOutlineGraphic = ImageUtils.loadImage(AresIO.ARES_IO.getFile(AresPaths.GRAPHICS_MEDIUM.getPath(), "Hexoutline.png"));
        for (int i = 0; i < boardInfo.getWidth(); i++) {
            for (int j = 0; j < boardInfo.getHeight(); j++) {
                hexImages[i][j] = hexOutlineGraphic;
            }
        }
        createGlobalHexesImage(hexImages);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    private int[] obtainTileFlags(Tile tile) {
        Map<Direction, Set<Terrain>> sideTerrain = tile.getSideTerrain();
        int[] flags = new int[Terrain.ALL_TERRAINS.length];
        for (Direction dir : sideTerrain.keySet()) {
            int boardInfotFlag = 1 << dir.ordinal();
            for (Terrain terr : sideTerrain.get(dir)) {
                flags[terr.ordinal()] |= boardInfotFlag;
            }
        }
        return flags;
    }

    private void loadGraphics() {
        terrainGraphics = new EnumMap<>(Terrain.class);
        for (int i = 0; i < Terrain.ALL_TERRAINS.length - 1; i++) {
            Terrain terrain = Terrain.ALL_TERRAINS[i];
            terrainGraphics.put(terrain, ImageUtils.splitImageHexagons(ImageUtils.loadImage(AresIO.ARES_IO.getFile(AresPaths.GRAPHICS_MEDIUM.getPath(), terrain.getGraphicFileMedium())), 8, 10));
        }
        terrainGraphics.put(Terrain.BORDER, ImageUtils.splitImageHexagons(ImageUtils.loadImage(AresIO.ARES_IO.getFile(AresPaths.GRAPHICS_MEDIUM.getPath(),Terrain.BORDER.getGraphicFileMedium())), 6, 3));
    }

    private BufferedImage flagsToImage(int[] flags, Tile tile) {
        Set<TerrainFeature> terrainFeatures = tile.getFeatures();
        BufferedImage bufImage = new BufferedImage(boardInfo.getHexDiameter(), boardInfo.getHexHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D gboardInfo = bufImage.createGraphics();
        AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);
        gboardInfo.setComposite(ac);
        // OPEN  TERRAIN
        gboardInfo.drawImage(terrainGraphics.get(Terrain.OPEN)[0], 0, 0, null);

        // STANDARD TERRAIN
        BufferedImage[] graphics;
        for (int pos = 0; pos < flags.length - 1; pos++) {
            int mask = flags[pos];
            if (mask != 0) {
                graphics = terrainGraphics.get(Terrain.ALL_TERRAINS[pos]);
                gboardInfo.drawImage(graphics[mask - 1], 0, 0, null);
            }
        }
        int pos = flags.length - 1;

        // BORDERS
        int mask = flags[pos];
        graphics = terrainGraphics.get(Terrain.ALL_TERRAINS[pos]);
        for (int boardInfot = 0; boardInfot < 6; boardInfot++) {
            if (testBitFlag(mask, boardInfot)) {
                gboardInfo.drawImage(graphics[boardInfot + 12], 0, 0, null);
            }
        }
        //WATER
        if (tile.getTileTerrain().contains(Terrain.DEEP_WATER) == false) {
            int maskDeep = 0;
            int maskShallow = 0;
            for (Map.Entry<Direction, Tile> neighbor : tile.getNeighbors().entrySet()) {
                if (neighbor.getValue().getTileTerrain().contains(Terrain.DEEP_WATER)) {
                    Direction dir = neighbor.getKey();
                    int boardInfotFlag = 1 << dir.ordinal();
                    maskDeep |= boardInfotFlag;
                } else if (neighbor.getValue().getTileTerrain().contains(Terrain.SHALLOW_WATER)) {
                    Direction dir = neighbor.getKey();
                    int boardInfotFlag = 1 << dir.ordinal();
                    maskShallow |= boardInfotFlag;
                }
            }
            if (maskShallow != 0) {
                graphics = terrainGraphics.get(Terrain.SHALLOW_WATER);
                if (maskShallow != 63) {
                    maskShallow = 62 - maskShallow;
                }
                gboardInfo.drawImage(graphics[maskShallow], 0, 0, null);
            }
            if (maskDeep != 0) {
                graphics = terrainGraphics.get(Terrain.DEEP_WATER);
                if (maskDeep != 63) {
                    maskDeep = 62 - maskDeep;
                }
                gboardInfo.drawImage(graphics[maskDeep], 0, 0, null);
            }
        }

        // MISCELANEOUS GRAPHICS (TERRAIN FEATURES)
        graphics = terrainGraphics.get(Terrain.OPEN);
        if (tile.getEntrechment() > 33 && tile.getEntrechment() <= 66) {
            gboardInfo.drawImage(graphics[30], 0, 0, null);
        } else if (tile.getEntrechment() > 66) {
            gboardInfo.drawImage(graphics[31], 0, 0, null);
        }
        for (TerrainFeature feature : terrainFeatures) {
            gboardInfo.drawImage(graphics[feature.ordinal() + 1], 0, 0, null);
        }

        return bufImage;
    }

    private void createGlobalTerrainImage(BufferedImage[][] images) {
        BufferedImage buffTerrainImage = new BufferedImage(boardInfo.getHexDiameter() + (boardInfo.getWidth() - 1) * boardInfo.getHexSide(), (int) (((boardInfo.getHeight() * 2) + 1) * boardInfo.getHexHeight()) / 2, BufferedImage.TYPE_INT_ARGB);
        Graphics2D gIR = buffTerrainImage.createGraphics();
        gIR.setColor(Color.BLACK);
        gIR.fillRect(0, 0, buffTerrainImage.getWidth(), buffTerrainImage.getHeight());
        for (int i = 0; i < boardInfo.getWidth(); i++) {
            int x = boardInfo.getHexSide() * i;
            for (int j = 0; j < boardInfo.getHeight(); j++) {
                int y = (int) (boardInfo.getHexHeight() * (2 * j + ((i + 1) % 2)) / 2);
                gIR.drawImage(images[i][j], x, y, null);
            }
        }
        terrainImage = buffTerrainImage;
    }

    private void createGlobalHexesImage(BufferedImage[][] images) {
        BufferedImage buffHexesImage = new BufferedImage(boardInfo.getHexDiameter() + (boardInfo.getWidth() - 1) * boardInfo.getHexSide(), (int) (((boardInfo.getHeight() * 2) + 1) * boardInfo.getHexHeight()) / 2, BufferedImage.TYPE_INT_ARGB);
        Graphics2D gIR = buffHexesImage.createGraphics();
        for (int i = 0; i < boardInfo.getWidth(); i++) {
            int x = boardInfo.getHexSide() * i;
            for (int j = 0; j < boardInfo.getHeight(); j++) {
                int y = boardInfo.getHexHeight() * (2 * j + ((i + 1) % 2)) / 2;
                gIR.drawImage(images[i][j], x, y, null);
            }
        }
        gridImage = buffHexesImage;
    }

//    public int getBoardImageWidth() {
//        return terrainImage.getWidth(null);
//    }
//
//    public int getBoardImageHeight() {
//        return terrainImage.getHeight(null);
//    }
//
//    public Dimension getBoardImageSize() {
//        return new Dimension(terrainImage.getWidth(null), terrainImage.getHeight(null));
//    }

    public void setShowGrid(boolean show) {
        showGrid = show;
        repaint();
    }

    static boolean testBitFlag(int mask, int boardInfot) {
        int flag = 1 << boardInfot;
        boolean boardInfotIsSet = (mask & flag) != 0;
        return boardInfotIsSet;
    }

    @Override
    public void paintComponent(Graphics g) {
        if (showGrid) {
            BufferedImage bufImage = new BufferedImage(terrainImage.getWidth(null), terrainImage.getHeight(null), BufferedImage.TYPE_INT_ARGB);
            Graphics2D gboardInfo = bufImage.createGraphics();
            AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);
            gboardInfo.setComposite(ac);
            gboardInfo.drawImage(terrainImage, 0, 0, null);
            gboardInfo.drawImage(gridImage, 0, 0, null);

            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            Dimension x = new Dimension(terrainImage.getWidth(this), terrainImage.getHeight(this));
            this.setPreferredSize(x);
            g2.drawImage(bufImage, 0, 0, bufImage.getWidth(this), bufImage.getHeight(this), this);
        } else {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;
            Dimension x = new Dimension(terrainImage.getWidth(this), terrainImage.getHeight(this));
            this.setPreferredSize(x);
            g2.drawImage(terrainImage, 0, 0, terrainImage.getWidth(this), terrainImage.getHeight(this), this);
        }
    }
}
